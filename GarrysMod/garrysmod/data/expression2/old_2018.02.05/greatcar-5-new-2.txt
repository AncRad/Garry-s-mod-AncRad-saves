#
# Created by scaled
#

# You need "holo" and "ranger" extentions.

# 2017-10-11 Record in gm_fork - 1m 23s.

@name greatcar-5-new-2
@model models/hunter/plates/plate2x3.mdl

# Inputs
@inputs [Chair1 Chair2]:entity

# Const
@persist MASS FORCE_MULTIPLIER
@persist WHEEL_LOCAL_POSES:array [WHEEL_SIZES WHEEL_WIDTHS]:vector4
@persist WHELL_MAX_FRICTION WHEEL_STREHTH WHEEL_SPEED_FADE
@persist ROTATE_MAX ROTATE_SMOOTH BUTTON_ROTATE_FADE ROTATE_RUL_MULTIPLIER
@persist ROTATE_CAM_OFFSET_FADE_SPEED ROTATE_CAM_OFFSET_FADE
@persist SUSPENSION_HEIGHT SUSPENSION_STRENGTH SUSPENSION_STABILITY
@persist MOVE_MAX_POWER MOVE_POWER_WHEELS:vector4
@persist MOVE_MAX_STOP_POWER MOVE_STOP_POWER
@persist MOVE_REALISTIC_MULTIPLIER MOVE_SKID_MULTIPLIER
@persist MOVE_STABILIZATION MOVE_STABILIZATION_ROTATE_MULTIPLIER MOVE_STABILIZATION_MOVE_PERCENT
@persist HOLO_SIZE HOLO_WHEEL_MAX_HEIGHT:vector4
@persist HOLO_OFFSET_WHEELS HOLO_OFFSET_STEERING_WHEEL
@persist BODY_FRONT_POS:vector BODY_TAN
@persist MOVE_SMALL_SPEED MOVE_SHIFT_MULTIPLIER
@persist [WHEELS_FRONT WHEELS_REAR WHEELS_LEFT WHEELS_RIGHT WHEELS_ALL VEC4_1]:vector4

# Persists
@persist Rotate RotateCamOffset ButtonRotate
@persist FirstTick
@persist H

# Temp arrays
@persist [WheelRangers Force]:array
@persist [WheelPoses WheelPosesOld WheelVelocities]:array
@persist [WheelRealForwardVelocity WheelRealForwardVelocityOld]:vector4
@persist [WheelWantForwardVelocity]:vector4
@persist [RangerHits RangerDistances]:vector4
@persist [WheelNotSkid WheelIsStabilized]:vector4
@persist WheelAngles:vector4

# Lights support for E2Power
#ifdef entity:setfLight(vector, vector, angle, string, number, number, number)
@persist LightKey LightsOn
@persist LIGHTS_POS:vector LIGHTS_LENGTH LIGHTS_FOV LIGHTS_MATERIAL:string
#endif

# Reset if duped
if (duped() | dupefinished()) {
    reset()
    exit()
}

# Functions
if (first()) {
    # Config
    function configure() {
        # Classic constants
        HOLO_SIZE = 12
        VEC4_1 = vec4(1)
        
        # Physical parameters
        MASS = 1800
        FORCE_MULTIPLIER = MASS * tickInterval()
        
        # Rotating
        ROTATE_MAX = 50
        #ROTATE_SMOOTH = 0.04
        ROTATE_SMOOTH = 0.05
        BUTTON_ROTATE_FADE = fromUnit("km/h", 20)
        ROTATE_CAM_OFFSET_FADE_SPEED = 2
        ROTATE_CAM_OFFSET_FADE = 20 / ROTATE_CAM_OFFSET_FADE_SPEED
        ROTATE_RUL_MULTIPLIER = 3
        
        # Suspension
        SUSPENSION_HEIGHT = 16.5
        SUSPENSION_STRENGTH = 60
        SUSPENSION_STABILITY = 6
        
        # Wheels
        WHELL_MAX_FRICTION = 8
        WHEEL_STREHTH = 5
        WHEEL_SPEED_FADE = 1
        
        # Moving
        MOVE_MAX_POWER = 200
        
        MOVE_MAX_STOP_POWER = 1500
        MOVE_STOP_POWER = 4
        
        #MOVE_REALISTIC_MULTIPLIER = 9
        MOVE_REALISTIC_MULTIPLIER = 12
        MOVE_SKID_MULTIPLIER = 0.9
        MOVE_SMALL_SPEED = fromUnit("km/h", 5)
        MOVE_SHIFT_MULTIPLIER = 0.6
        
        MOVE_STABILIZATION = 1
        MOVE_STABILIZATION_ROTATE_MULTIPLIER = 0.5
        MOVE_STABILIZATION_MOVE_PERCENT = 0.8
        
        # Drive
        WHEELS_FRONT = vec4(
            1, 1,
            0, 0
        ) / 2
        WHEELS_REAR = vec4(
            0, 0,
            1, 1
        ) / 2
        WHEELS_LEFT = vec4(
            1, 0,
            1, 0
        ) / 2
        WHEELS_RIGHT = vec4(
            0, 1,
            0, 1
        ) / 2
        WHEELS_ALL = vec4(
            1, 1,
            1, 1
        ) / 4
        
        MOVE_POWER_WHEELS = WHEELS_REAR
        
        # Lights (only for E2Power addon)
        #ifdef entity:setfLight(vector, vector, angle, string, number, number, number)
        LIGHTS_LENGTH = 600
        LIGHTS_FOV = 105
        LIGHTS_MATERIAL = "models/debug/debugwhite"
        #LIGHTS_MATERIAL = "effects/flashlight/gradient"
        #endif
    }
    
    # Code
    function initialize() {
        runOnTick(1)
        FirstTick = 1
        
        # Set physical parameters
        entity():setAlpha(0)
        entity():setMass(MASS)
        Chair1:setMass(0)
        Chair2:setMass(0)
        Chair1:setAlpha(0)
        Chair2:setAlpha(0)
        
        # Need for clearing lights if last
        #ifdef entity:setfLight(vector, vector, angle, string, number, number, number)
        runOnLast(1)
        #endif
    }
    
    function holoPlaneBack(Color:vector) {
        H++
        local HoloPrevious = holoEntity(H - 1)
        holoCreate(H,
            HoloPrevious:pos(),
            holoScale(H-1),
            HoloPrevious:toWorld(ang(180, 0, 0)),
            Color,
            "plane"
        )
        holoParent(H, 1)
    }

    function holoFromPointOffset(Point1:vector, Offset:vector, Direction:vector, Color:vector, Width, Side) {
        local Normal = Direction:cross(Offset)
        
        H++
        holoCreate(H,
            Point1 + Offset / 2,
            vec(Offset:length(), Width, 1) / HOLO_SIZE,
            Normal:toAngle() + Side * ang(90, 0, 0),
            Color,
            "plane"
        )
        holoParent(H, 1)
    }

    function holoFromPoints(Point1:vector, Point2:vector, Direction:vector, Color:vector, Width, Side) {
        local Offset = Point2 - Point1
        local Normal = Direction:cross(Offset)
        
        H++
        holoCreate(H,
            Point1 + Offset / 2,
            vec(Offset:length(), Width, 1) / HOLO_SIZE,
            Normal:toAngle() + Side * ang(90, 0, 0),
            Color,
            "plane"
        )
        holoParent(H, 1)
    }

    function holoReflect() {
        H++
        local HoloPrevious = holoEntity(H-1)
        holoCreate(H,
            HoloPrevious:pos() * vec(-1, 1, 1),
            holoScale(H-1),
            HoloPrevious:angles(),
            HoloPrevious:getColor(),
            "plane"
        )
        holoParent(H, 1)
    }
    
    function holoClipPoints(ClipId, Pos0:vector, Pos1:vector, Normal:vector, Direction) {
        holoClipEnabled(H, ClipId, 1)
        local Normal1 = Normal:cross(Pos1 - Pos0) * Direction
        holoClip(H, ClipId,
            holoEntity(H):toLocal(Pos0),
            holoEntity(H):toLocalAxis(Normal1),
            0
        )
    }
    
    function number bodyGetHeight(Pos) {
        return BODY_FRONT_POS[3] + (-BODY_FRONT_POS[2] + Pos) * BODY_TAN
    }

    
    function drawBody() {
        local HOLO_MIN_DISTANCE = 0.2

        #local COLOR = vec(242, 242, 255)
        local COLOR = vec(10)
        #local COLOR = vec(255, 200, 50)
        local COLOR_INSIDE = vec(30)
        local COLOR_INTERIOR = vec(60)
        local COLOR_INTERIOR2 = vec(80)
        #local COLOR_INTERIOR = vec(140, 110, 90)
        #local COLOR_INTERIOR = vec(220, 195, 160)
        local COLOR_LIGHTS = vec(255)
        local COLOR_LIGHTS_RED = vec(255, 0, 0)
        local COLOR_DISK = vec(160)
        local COLOR_WHEELS = vec(20)
        local COLOR_GLASS = vec4(255, 255, 255, 80)

        local MATERIAL_SHINY = "models/shiny"
        #local MATERIAL_SHINY = "debug/debugdrawflat"
        local MATERIAL_MIRROR = "debug/env_cubemap_model"
        local MATERIAL_GLASS = "debug/env_cubemap_model"

        local BODY_WIDTH = 72
        local BODY_LENGTH = 142

        local INTERIOR_LENGTH = 54

        local BASE_WIDTH = BODY_WIDTH - 30
        local BASE_FRONT_HEIGHT = vec(0, -7.5, 21.5)
        local BASE_BACK_HEIGHT = vec(0, 3, 27)

        # Compute INTERIOR_FRONT_HEIGHT and INTERIOR_BACK_HEIGHT from input angle
        BODY_FRONT_POS = vec(0, -BODY_LENGTH / 2, 0) + BASE_FRONT_HEIGHT
        local Offset = vec(0, BODY_LENGTH / 2, 0) + BASE_BACK_HEIGHT - BODY_FRONT_POS
        BODY_TAN = Offset[3] / Offset[2]
        
        local INTERIOR_FRONT_HEIGHT = bodyGetHeight(-INTERIOR_LENGTH / 2)
        local INTERIOR_BACK_HEIGHT  = bodyGetHeight(INTERIOR_LENGTH / 2)

        local TRUNK_BACK_LENGTH = 6

        local MIRRORS_WIDTH = 10
        local MIRRORS_HEIGHT = 6
        local MIRROR_ANGLE = 20

        local ROOF_WIDTH = 50
        local ROOF_LENGTH = 40
        local ROOF_POS = vec(0, 14, 44.5)
        
        local LIGHTS_UP_OFFSET = 4
        local LIGHTS_DOWN_OFFSET = 4
        local LIGHTS_FRONT_UP_SIZE = 26
        local LIGHTS_FRONT_DOWN_SIZE = 12

        WHEEL_WIDTHS = vec4(
            13, 13,
            14, 14
        )
        local WHEEL_SIDE_CLEARANCE = 4
        WHEEL_LOCAL_POSES = array(
            vec( (BASE_WIDTH + WHEEL_WIDTHS[1]) / 2 + WHEEL_SIDE_CLEARANCE, -(BODY_LENGTH + INTERIOR_LENGTH) / 4, 0),
            vec(-(BASE_WIDTH + WHEEL_WIDTHS[2]) / 2 - WHEEL_SIDE_CLEARANCE, -(BODY_LENGTH + INTERIOR_LENGTH) / 4, 0),
            vec( (BASE_WIDTH + WHEEL_WIDTHS[3]) / 2 + WHEEL_SIDE_CLEARANCE,  (BODY_LENGTH + INTERIOR_LENGTH) / 4, 0),
            vec(-(BASE_WIDTH + WHEEL_WIDTHS[4]) / 2 - WHEEL_SIDE_CLEARANCE,  (BODY_LENGTH + INTERIOR_LENGTH) / 4, 0)
        )
        
        local SUSPENSION_DEFECT = 1.3
        local WHEEL_ARCH_CLEARANCE = 3
        
        for (I = 1, 4) {
            WHEEL_SIZES[I] = bodyGetHeight(WHEEL_LOCAL_POSES[I, vector][2]) * cos(atan(BODY_TAN)) + SUSPENSION_HEIGHT - SUSPENSION_DEFECT - WHEEL_ARCH_CLEARANCE - 3
            HOLO_WHEEL_MAX_HEIGHT[I] = bodyGetHeight(WHEEL_LOCAL_POSES[I, vector][2]) - WHEEL_SIZES[I] / 2 - HOLO_MIN_DISTANCE - 1.5
        }
        
        #local WHEEL_AND_DISK_MODEL = "hq_tube"
        #local DISK_THICK = 0.75
        local WHEEL_AND_DISK_MODEL = "hq_tube_thin"
        local DISK_THICK = 0.9
        
        local DISK_SIZE = WHEEL_SIZES * (DISK_THICK ^ 2 - 0.05)
        local DISK_CENTER_DEPTH = 3
        local DISK_STICK_COUNT = 5
        #local DISK_CENTER_SIZE = 8
        #local DISK_STICK_WIDTH = DISK_CENTER_SIZE * sin(180 / DISK_STICK_COUNT)
        #local DISK_STICK_WIDTH = 4
        #local DISK_CENTER_SIZE = DISK_STICK_WIDTH / sin(180 / DISK_STICK_COUNT)
        local DISK_STICK_WIDTH = 4
        local DISK_CENTER_SIZE = 0
        
        LIGHTS_POS = vec(0, -BODY_LENGTH / 2, 0) + BASE_FRONT_HEIGHT
        
        local RUL_RADIUS = 8
        local RUL_CORNERS = 5
        local RUL_THICK = 2
        
        local CHAIR_BACK_SIZE = vec(22, 5, 30)
        local CHAIR_BASE_SIZE = vec(22, 25, 5)
        local CHAIR_ANGLE = 6

        # Interior bottom
        H++
        holoCreate(H,
            vec(),
            vec(BODY_WIDTH, INTERIOR_LENGTH, 1) / HOLO_SIZE,
            ang(),
            COLOR_INTERIOR,
            "plane"
        )
        holoParent(H, entity())

        ## Back panel
        holoFromPointOffset(
            vec(0, BODY_LENGTH / 2, 0),
            BASE_BACK_HEIGHT,
            vec(1, 0, 0),
            COLOR,
            BODY_WIDTH,
            -1
        )
        local HoloBackPanel = H
        holoMaterial(H, MATERIAL_SHINY)

        holoPlaneBack(COLOR_INSIDE)

        ## Front panel
        holoFromPointOffset(
            vec(0, -BODY_LENGTH / 2, 0),
            BASE_FRONT_HEIGHT,
            vec(1, 0, 0),
            COLOR,
            BODY_WIDTH,
            1
        )
        local HoloFrontPanel = H
        holoMaterial(H, MATERIAL_SHINY)

        holoPlaneBack(COLOR_INSIDE)
        
        # Trunk parts
        ## Back part
        local Pos0 = vec(0, BODY_LENGTH / 2, 0) + BASE_BACK_HEIGHT
        local Pos1 = vec(0, INTERIOR_LENGTH / 2, INTERIOR_BACK_HEIGHT)
        local Offset = Pos1 - Pos0
        local TRUNK_BACK_POS = Pos0 + Offset:normalized() * TRUNK_BACK_LENGTH
        holoFromPoints(
            Pos0,
            TRUNK_BACK_POS,
            vec(1, 0, 0),
            COLOR,
            BODY_WIDTH,
            -1
        )
        holoMaterial(H, MATERIAL_SHINY)
        
        ## Up
        holoFromPoints(
            vec(0, INTERIOR_LENGTH / 2 - HOLO_MIN_DISTANCE, INTERIOR_BACK_HEIGHT),
            TRUNK_BACK_POS,
            vec(1, 0, 0),
            COLOR_INTERIOR,
            BODY_WIDTH,
            1
        )
        
        ## Up back side
        holoFromPoints(
            vec(0, INTERIOR_LENGTH / 2, INTERIOR_BACK_HEIGHT),
            Pos0,
            vec(1, 0, 0),
            COLOR_INSIDE,
            BODY_WIDTH,
            -1
        )
        
        ## Center
        H++
        holoCreate(H,
            vec(0, ((BODY_LENGTH / 2 + BASE_BACK_HEIGHT[2]) + INTERIOR_LENGTH / 2) / 2, BASE_BACK_HEIGHT[3] / 2) + vec(0, HOLO_MIN_DISTANCE, HOLO_MIN_DISTANCE) / 2,
            (vec(BASE_WIDTH, ((BODY_LENGTH / 2 + BASE_BACK_HEIGHT[2]) - INTERIOR_LENGTH / 2), BASE_BACK_HEIGHT[3]) + vec(0, HOLO_MIN_DISTANCE, HOLO_MIN_DISTANCE)) / HOLO_SIZE,
            ang(),
            COLOR_INSIDE
        )
        holoParent(H, 1)
        
        holoClipPoints(1,
            vec(0, BODY_LENGTH / 2, 0) + BASE_BACK_HEIGHT,
            vec(0, INTERIOR_LENGTH / 2, INTERIOR_BACK_HEIGHT),
            vec(1, 0, 0),
            1
        )
        
        holoClipPoints(2,
            vec(0, BODY_LENGTH / 2, 0),
            vec(0, BODY_LENGTH / 2, 0) + BASE_BACK_HEIGHT,
            vec(1, 0, 0),
            1
        )

        #Back lights
        ## Red big light
        H++
        holoCreate(H,
            holoEntity(HoloBackPanel):toWorld(vec(BASE_BACK_HEIGHT:length() / 4 + 1.5, 0, HOLO_MIN_DISTANCE)),
            vec(3, BODY_WIDTH - 18, 1) / HOLO_SIZE,
            holoEntity(HoloBackPanel):angles(),
            COLOR_LIGHTS_RED,
            "plane"
        )
        holoParent(H, 1)
        holoDisableShading(H, 1)

        ## White decor
        ### Left
        H++
        holoCreate(H,
            holoEntity(HoloBackPanel):toWorld(vec(-BASE_BACK_HEIGHT:length() / 8, 8, HOLO_MIN_DISTANCE)),
            vec(BASE_BACK_HEIGHT:length() * 0.75, 3, 1) / HOLO_SIZE,
            holoEntity(HoloBackPanel):angles(),
            COLOR_LIGHTS,
            "plane"
        )
        holoParent(H, 1)
        holoDisableShading(H, 1)

        ### Right
        holoReflect()
        holoDisableShading(H, 1)

        # Bonnet
        holoFromPoints(
            vec(0, -BODY_LENGTH / 2, 0) + BASE_FRONT_HEIGHT,
            vec(0, -INTERIOR_LENGTH / 2, INTERIOR_FRONT_HEIGHT),
            vec(1, 0, 0),
            COLOR,
            BODY_WIDTH,
            1
        )
        holoMaterial(H, MATERIAL_SHINY)

        holoPlaneBack(COLOR_INSIDE)
        
        ## Center
        H++
        holoCreate(H,
            vec(0, -((BODY_LENGTH / 2 + -BASE_FRONT_HEIGHT[2]) + INTERIOR_LENGTH / 2) / 2, INTERIOR_FRONT_HEIGHT / 2) + vec(0, -HOLO_MIN_DISTANCE, HOLO_MIN_DISTANCE) / 2,
            (vec(BASE_WIDTH, ((BODY_LENGTH / 2 + -BASE_FRONT_HEIGHT[2]) - INTERIOR_LENGTH / 2), INTERIOR_FRONT_HEIGHT) + vec(0, HOLO_MIN_DISTANCE, HOLO_MIN_DISTANCE)) / HOLO_SIZE,
            ang(),
            COLOR_INSIDE
        )
        holoParent(H, 1)
        
        holoClipPoints(1,
            vec(0, -BODY_LENGTH / 2, 0) + BASE_FRONT_HEIGHT,
            vec(0, -INTERIOR_LENGTH / 2, INTERIOR_FRONT_HEIGHT),
            vec(1, 0, 0),
            -1
        )
        
        holoClipPoints(2,
            vec(0, -BODY_LENGTH / 2, 0),
            vec(0, -BODY_LENGTH / 2, 0) + BASE_FRONT_HEIGHT,
            vec(1, 0, 0),
            -1
        )

        ## End
        holoFromPointOffset(
            vec(0, -INTERIOR_LENGTH / 2 + HOLO_MIN_DISTANCE, 0),
            vec(0, 0, INTERIOR_FRONT_HEIGHT),
            vec(1, 0, 0),
            COLOR_INTERIOR,
            BODY_WIDTH,
            -1
        )
        
        # Lights
        ## Left up
        H++
        holoCreate(H,
            holoEntity(HoloFrontPanel):toWorld(vec(-BASE_FRONT_HEIGHT:length() / 2 + 1.5 + LIGHTS_UP_OFFSET, (-BODY_WIDTH + LIGHTS_FRONT_UP_SIZE) / 2, HOLO_MIN_DISTANCE)),
            vec(3, LIGHTS_FRONT_UP_SIZE, 1) / HOLO_SIZE,
            holoEntity(HoloFrontPanel):angles(),
            COLOR_LIGHTS,
            "plane"
        )
        holoParent(H, 1)
        holoDisableShading(H, 1)

        ## Right up
        holoReflect()
        holoDisableShading(H, 1)

        ## Left down
        H++
        holoCreate(H,
            holoEntity(HoloFrontPanel):toWorld(vec(BASE_FRONT_HEIGHT:length() / 2 - 1.5 - LIGHTS_DOWN_OFFSET, (-BODY_WIDTH - LIGHTS_FRONT_DOWN_SIZE) / 2 + LIGHTS_FRONT_UP_SIZE, HOLO_MIN_DISTANCE)),
            vec(3, LIGHTS_FRONT_DOWN_SIZE, 1) / HOLO_SIZE,
            holoEntity(HoloFrontPanel):angles(),
            COLOR_LIGHTS,
            "plane"
        )
        holoParent(H, 1)
        holoDisableShading(H, 1)

        ## Right down
        holoReflect()
        holoDisableShading(H, 1)

        # Interior
        ## Panel
        H++
        holoCreate(H,
            vec(0, -INTERIOR_LENGTH / 2 + 4, INTERIOR_FRONT_HEIGHT - 6),
            (vec(BODY_WIDTH, 8, 12) - vec(HOLO_MIN_DISTANCE, HOLO_MIN_DISTANCE, 0) * 2) / HOLO_SIZE,
            ang(),
            COLOR_INTERIOR2
        )
        holoParent(H, 1)


        ### Steering wheel
        H++
        HOLO_OFFSET_STEERING_WHEEL = H
        local STEERING_WHEEL_POS = holoEntity(H-1):toWorld(vec(BODY_WIDTH / 4, 4 + 2, 0))
        holoCreate(H,
            STEERING_WHEEL_POS,
            vec(RUL_THICK, (RUL_RADIUS - RUL_THICK / 2) * 2 * cos(180 / RUL_CORNERS), RUL_THICK) / HOLO_SIZE,
            holoEntity(H-1):toWorld(ang(-10, 90, 0)),
            COLOR_INTERIOR2
        )
        holoParent(H, 1)
        for (I = 1, RUL_CORNERS) {
            local Angle = (I + 0.5) / RUL_CORNERS * 360
            H++
            holoCreate(H,
                holoEntity(HOLO_OFFSET_STEERING_WHEEL):toWorld((RUL_RADIUS - RUL_THICK / 2 / cos(180 / RUL_CORNERS)) * vec(0, sin(Angle), cos(Angle)) * cos(180 / RUL_CORNERS)),
                vec(RUL_THICK, 2 * RUL_RADIUS * sin(180 / RUL_CORNERS), RUL_THICK) / HOLO_SIZE,
                holoEntity(HOLO_OFFSET_STEERING_WHEEL):toWorld(ang(0, 0, -Angle)),
                COLOR_INTERIOR2
            )
            holoParent(H, HOLO_OFFSET_STEERING_WHEEL)
        }

        # Interior
        ## Left
        H++
        holoCreate(H,
            vec(BODY_WIDTH / 2, 0, INTERIOR_BACK_HEIGHT / 2),
            vec(INTERIOR_BACK_HEIGHT, INTERIOR_LENGTH, 1) / HOLO_SIZE,
            ang(90, 0, 0),
            COLOR,
            "plane"
        )
        holoParent(H, 1)
        holoMaterial(H, MATERIAL_SHINY)
        
        holoClipPoints(1,
            vec(0, BODY_LENGTH / 2, 0) + BASE_BACK_HEIGHT,
            vec(0, -BODY_LENGTH / 2, 0) + BASE_FRONT_HEIGHT,
            vec(1, 0, 0),
            1
        )
        
        ## Right
        holoReflect()
        holoAng(H, ang(-90, 0, 0))
        holoMaterial(H, MATERIAL_SHINY)
        
        holoClipPoints(1,
            vec(0, BODY_LENGTH / 2, 0) + BASE_BACK_HEIGHT,
            vec(0, -BODY_LENGTH / 2, 0) + BASE_FRONT_HEIGHT,
            vec(1, 0, 0),
            1
        )

        ## Left
        H++
        holoCreate(H,
            vec(BODY_WIDTH / 2, 0, INTERIOR_BACK_HEIGHT / 2),
            vec(INTERIOR_BACK_HEIGHT, INTERIOR_LENGTH, 1) / HOLO_SIZE,
            ang(-90, 0, 0),
            COLOR_INTERIOR,
            "plane"
        )
        holoParent(H, 1)
        
        holoClipPoints(1,
            vec(0, BODY_LENGTH / 2, 0) + BASE_BACK_HEIGHT,
            vec(0, -BODY_LENGTH / 2, 0) + BASE_FRONT_HEIGHT,
            vec(1, 0, 0),
            1
        )

        ## Right
        holoReflect()
        holoAng(H, ang(90, 0, 0))
        
        holoClipPoints(1,
            vec(0, BODY_LENGTH / 2, 0) + BASE_BACK_HEIGHT,
            vec(0, -BODY_LENGTH / 2, 0) + BASE_FRONT_HEIGHT,
            vec(1, 0, 0),
            1
        )

        ## Back
        holoFromPointOffset(
            vec(0, INTERIOR_LENGTH / 2 - HOLO_MIN_DISTANCE, 0),
            vec(0, 0, bodyGetHeight(INTERIOR_LENGTH / 2 - HOLO_MIN_DISTANCE)),
            vec(1, 0, 0),
            COLOR_INTERIOR,
            BODY_WIDTH,
            1
        )
        
        ## Outside center
        H++
        holoCreate(H,
            vec(0, 0, INTERIOR_BACK_HEIGHT / 2 + HOLO_MIN_DISTANCE / 2),
            vec(BODY_WIDTH - HOLO_MIN_DISTANCE * 2, INTERIOR_LENGTH, INTERIOR_BACK_HEIGHT + HOLO_MIN_DISTANCE) / HOLO_SIZE,
            ang(),
            COLOR_INSIDE
        )
        holoParent(H, 1)
        
        holoClipPoints(1,
            vec(0, BODY_LENGTH / 2, 0) + BASE_BACK_HEIGHT,
            vec(0, -BODY_LENGTH / 2, 0) + BASE_FRONT_HEIGHT,
            vec(1, 0, 0),
            1
        )

        
        ## Seats
        #local CHAIR_BACKWARD_CLEARANCE = CHAIR_BACK_SIZE[3] * sin(CHAIR_ANGLE)
        local CHAIR_BACKWARD_CLEARANCE = bodyGetHeight(INTERIOR_LENGTH / 2 - HOLO_MIN_DISTANCE) * tan(CHAIR_ANGLE)
        H++
        holoCreate(H,
            vec(BODY_WIDTH / 4, INTERIOR_LENGTH / 2 - CHAIR_BASE_SIZE[2] / 2 - CHAIR_BACKWARD_CLEARANCE - HOLO_MIN_DISTANCE, CHAIR_BASE_SIZE[3] / 2 + HOLO_MIN_DISTANCE),
            CHAIR_BASE_SIZE / HOLO_SIZE,
            ang(),
            COLOR_INTERIOR2
        )
        holoParent(H, 1)
        
        holoReflect()
        holoModel(H, "cube")
        
        H++
        holoCreate(H,
            holoEntity(H - 2):pos()
            + vec(0, CHAIR_BASE_SIZE[2], -CHAIR_BASE_SIZE[3]) / 2
            + vec(
                0,
                CHAIR_BACK_SIZE[3] / 2 * sin(CHAIR_ANGLE) - CHAIR_BACK_SIZE[2] * cos(CHAIR_ANGLE) / 2,
                CHAIR_BACK_SIZE[3] / 2 * cos(CHAIR_ANGLE) + CHAIR_BACK_SIZE[2] * sin(CHAIR_ANGLE) / 2
            ),
            CHAIR_BACK_SIZE / HOLO_SIZE,
            ang(0, 0, -CHAIR_ANGLE),
            COLOR_INTERIOR2
        )
        holoParent(H, 1)
        
        holoReflect()
        holoModel(H, "cube")
        
        # Setup chair
        #[local CHAIR_HEIGHT = 0
        local CHAIR_BACKWARD_CLEARANCE = 1
        Chair1:setPos(entity():toWorld(vec( BODY_WIDTH / 4, INTERIOR_LENGTH / 2 - Chair1:aabbSize()[2] / 2 - CHAIR_BACKWARD_CLEARANCE, CHAIR_HEIGHT) + Chair1:boxCenter():setZ(0)))
        Chair2:setPos(entity():toWorld(vec(-BODY_WIDTH / 4, INTERIOR_LENGTH / 2 - Chair1:aabbSize()[2] / 2 - CHAIR_BACKWARD_CLEARANCE, CHAIR_HEIGHT) + Chair1:boxCenter():setZ(0)))
        
        Chair1:setAng(entity():toWorld(ang(0, 180, 0)))
        Chair2:setAng(entity():toWorld(ang(0, 180, 0)))]#



        # Mirror
        ## Left
        holoFromPointOffset(
            vec(BODY_WIDTH / 2, -INTERIOR_LENGTH / 2, INTERIOR_FRONT_HEIGHT + MIRRORS_HEIGHT / 2),
            vec(cos(MIRROR_ANGLE), sin(MIRROR_ANGLE), 0) * MIRRORS_WIDTH,
            vec(0, 0, 1),
            COLOR,
            MIRRORS_HEIGHT,
            -1
        )
        holoScale(H, vec(MIRRORS_HEIGHT, MIRRORS_WIDTH, 1) / HOLO_SIZE)
        holoMaterial(H, MATERIAL_SHINY)

        holoPlaneBack(vec(255))
        holoPos(H, holoEntity(H-1):toWorld(vec(0, 0, -HOLO_MIN_DISTANCE)))
        holoMaterial(H, MATERIAL_MIRROR)

        ## Right
        holoFromPointOffset(
            vec(-BODY_WIDTH / 2, -INTERIOR_LENGTH / 2, INTERIOR_FRONT_HEIGHT + MIRRORS_HEIGHT / 2),
            vec(-cos(MIRROR_ANGLE), sin(MIRROR_ANGLE), 0) * MIRRORS_WIDTH,
            vec(0, 0, 1),
            COLOR,
            MIRRORS_HEIGHT,
            1
        )
        holoScale(H, vec(MIRRORS_HEIGHT, MIRRORS_WIDTH, 1) / HOLO_SIZE)
        holoParent(H, 1)
        holoMaterial(H, MATERIAL_SHINY)

        holoPlaneBack(vec(255))
        holoPos(H, holoEntity(H-1):toWorld(vec(0, 0, -HOLO_MIN_DISTANCE)))
        holoMaterial(H, MATERIAL_MIRROR)


        # Roof
        H++
        HOLO_ROOF = H
        holoCreate(H,
            ROOF_POS,
            vec(ROOF_WIDTH, ROOF_LENGTH, 1) / HOLO_SIZE,
            ang(0, 0, atan(BODY_TAN)),
            COLOR,
            "plane"
        )
        holoParent(H, 1)
        holoMaterial(H, MATERIAL_SHINY)
        
        holoPlaneBack(COLOR_INTERIOR)

        # Glass
        ## Constants
        local ROOF_RELATIVE_HEIGHT = ROOF_POS[3] - bodyGetHeight(ROOF_POS[2])
        
        local ROOF_FRONT_POS = holoEntity(HOLO_ROOF):toWorld(vec(0, -ROOF_LENGTH / 2, 0))
        local ROOF_BACK_POS = holoEntity(HOLO_ROOF):toWorld(vec(0, ROOF_LENGTH / 2, 0))
        
        local ROOF_LEFT_POS = ROOF_POS + vec(ROOF_WIDTH / 2, 0, 0)
        local ROOF_RIGHT_POS = ROOF_POS - vec(ROOF_WIDTH / 2, 0, 0)
        
        ## Left
        local Y = (-INTERIOR_LENGTH / 2 + TRUNK_BACK_POS[2]) / 2
        local Pos00 = vec(ROOF_WIDTH / 2, Y, bodyGetHeight(Y) + ROOF_RELATIVE_HEIGHT)
        local Pos01 = vec(BODY_WIDTH / 2, Y, bodyGetHeight(Y))
        local Offset0 = Pos01 - Pos00

        local Pos10 = vec(0, -INTERIOR_LENGTH / 2, INTERIOR_FRONT_HEIGHT)
        local Pos11 = TRUNK_BACK_POS
        local Offset1 = Pos11 - Pos10
        H++
        holoCreate(H,
            (Pos00 + Pos01) / 2,
            vec(Offset1:length(), Offset0:length(), 1) / HOLO_SIZE,
            ang(-atan(BODY_TAN), 90, 90 + atan(Offset0[1] / Offset0[3])),
            vec(COLOR_GLASS),
            "plane"
        )
        holoAlpha(H, COLOR_GLASS[4])
        holoMaterial(H, MATERIAL_GLASS)
        holoParent(H, 1)

        holoClipPoints(1,
            ROOF_BACK_POS,
            TRUNK_BACK_POS,
            vec(1, 0, 0),
            -1
        )

        holoClipPoints(2,
            ROOF_FRONT_POS,
            vec(0, -INTERIOR_LENGTH / 2, INTERIOR_FRONT_HEIGHT),
            vec(1, 0, 0),
            1
        )

        ## Right
        H++
        holoCreate(H,
            (Pos00 + Pos01) / 2 * vec(-1, 1, 1),
            vec(Offset1:length(), Offset0:length(), 1) / HOLO_SIZE,
            ang(-atan(BODY_TAN), 90, 90 - atan(Offset0[1] / Offset0[3])),
            vec(COLOR_GLASS),
            "plane"
        )
        holoAlpha(H, COLOR_GLASS[4])
        holoMaterial(H, MATERIAL_GLASS)
        holoParent(H, 1)

        holoClipPoints(1,
            ROOF_BACK_POS,
            TRUNK_BACK_POS,
            vec(1, 0, 0),
            -1
        )

        holoClipPoints(2,
            ROOF_FRONT_POS,
            vec(0, -INTERIOR_LENGTH / 2, INTERIOR_FRONT_HEIGHT),
            vec(1, 0, 0),
            1
        )

        ## Front
        local Pos0 = ROOF_FRONT_POS
        local Pos1 = vec(0, -INTERIOR_LENGTH / 2, INTERIOR_FRONT_HEIGHT)
        local Offset = Pos1 - Pos0

        H++
        holoCreate(H,
            (Pos0 + Pos1) / 2 * vec(-1, 1, 1),
            vec(BODY_WIDTH, Offset:length(), 1) / HOLO_SIZE,
            ang(0, 0, atan(Offset[3] / Offset[2])),
            vec(COLOR_GLASS),
            "plane"
        )
        holoAlpha(H, COLOR_GLASS[4])
        holoMaterial(H, MATERIAL_GLASS)
        holoParent(H, 1)

        holoClipPoints(1,
            ROOF_LEFT_POS,
            vec(BODY_WIDTH / 2, 0, bodyGetHeight(ROOF_POS[2])),
            vec(0, 1, BODY_TAN),
            1
        )

        holoClipPoints(2,
            ROOF_RIGHT_POS,
            vec(-BODY_WIDTH / 2, 0, bodyGetHeight(ROOF_POS[2])),
            vec(0, 1, BODY_TAN),
            -1
        )


        ## Back
        local Pos0 = ROOF_BACK_POS
        local Pos1 = TRUNK_BACK_POS
        local Offset = Pos1 - Pos0

        H++
        holoCreate(H,
            (Pos0 + Pos1) / 2 * vec(-1, 1, 1),
            vec(BODY_WIDTH, Offset:length(), 1) / HOLO_SIZE,
            ang(0, 0, atan(Offset[3] / Offset[2])),
            vec(COLOR_GLASS),
            "plane"
        )
        holoAlpha(H, COLOR_GLASS[4])
        holoMaterial(H, MATERIAL_GLASS)
        holoParent(H, 1)

        holoClipPoints(1,
            ROOF_LEFT_POS,
            vec(BODY_WIDTH / 2, 0, bodyGetHeight(ROOF_POS[2])),
            vec(0, 1, BODY_TAN),
            1
        )

        holoClipPoints(2,
            ROOF_RIGHT_POS,
            vec(-BODY_WIDTH / 2, 0, bodyGetHeight(ROOF_POS[2])),
            vec(0, 1, BODY_TAN),
            -1
        )
        
        #Wheels
        HOLO_OFFSET_WHEELS = H
        
        for (I = 1, 4) {
            H++
            holoCreate(H,
                WHEEL_LOCAL_POSES[I, vector],
                vec(WHEEL_SIZES[I], WHEEL_SIZES[I], WHEEL_WIDTHS[I]) / HOLO_SIZE,
                ang(90 * (I % 2 ? 1 : -1), 0, 0),
                COLOR_WHEELS,
                WHEEL_AND_DISK_MODEL
            )
            holoParent(H, 1)
        }
        
        for (I = 1, 4) {
            H++
            holoCreate(H,
                WHEEL_LOCAL_POSES[I, vector],
                vec(DISK_THICK * WHEEL_SIZES[I], DISK_THICK * WHEEL_SIZES[I], WHEEL_WIDTHS[I]) / HOLO_SIZE,
                ang(90 * (I % 2 ? 1 : -1), 0, 0),
                COLOR_WHEELS,
                WHEEL_AND_DISK_MODEL
            )
            holoParent(H, HOLO_OFFSET_WHEELS + I)
        }
        
        for (I = 1, 4) {
            local HOLO_WHEEL = HOLO_OFFSET_WHEELS + I
            
            # Outside disk
            H++
            holoCreate(H,
                holoEntity(HOLO_WHEEL):pos(),
                vec(DISK_SIZE[I] / DISK_THICK, DISK_SIZE[I] / DISK_THICK, WHEEL_WIDTHS[I] - HOLO_MIN_DISTANCE * 2) / HOLO_SIZE,
                holoEntity(HOLO_WHEEL):angles(),
                COLOR_DISK,
                WHEEL_AND_DISK_MODEL
            )
            holoParent(H, HOLO_WHEEL)
            holoMaterial(H, MATERIAL_SHINY)
            
            # Center
            #[H++
            holoCreate(H,
                holoEntity(HOLO_WHEEL):toWorld(vec(0, 0, WHEEL_WIDTHS[I] / 2 - DISK_CENTER_DEPTH)),
                vec(DISK_CENTER_SIZE, DISK_CENTER_SIZE, 1) / HOLO_SIZE,
                holoEntity(HOLO_WHEEL):angles(),
                COLOR_DISK,
                "cplane"
            )
            holoParent(H, HOLO_WHEEL)
            holoMaterial(H, MATERIAL_SHINY)]#
            
            # Stick
            for (J = 1, DISK_STICK_COUNT) {
                local Angle = J / DISK_STICK_COUNT * 360
                local StickPos = (DISK_SIZE[I] + DISK_CENTER_SIZE * cos(180 / DISK_STICK_COUNT)) / 4
                local Length = (DISK_SIZE[I] - DISK_CENTER_SIZE * cos(180 / DISK_STICK_COUNT)) / 2
                local Tan = (DISK_CENTER_DEPTH - HOLO_MIN_DISTANCE * 2) / Length
                H++
                holoCreate(H,
                    holoEntity(HOLO_WHEEL):toWorld(vec(StickPos * cos(Angle), StickPos * sin(Angle), (WHEEL_WIDTHS[I] - DISK_CENTER_DEPTH - HOLO_MIN_DISTANCE * 2) / 2)),
                    vec(vec2(Length, DISK_CENTER_DEPTH):length(), DISK_STICK_WIDTH, (WHEEL_WIDTHS[I] - HOLO_MIN_DISTANCE) / 2) / HOLO_SIZE,
                    holoEntity(HOLO_WHEEL):toWorld(ang(-atan(Tan), Angle, 0)),
                    COLOR_DISK,
                    "plane"
                )
                holoParent(H, HOLO_WHEEL)
                holoMaterial(H, MATERIAL_SHINY)
            }
        }
        holoPos(1, entity():toWorld(vec(0, 0, -entity():boxSize()[3] / 2)))
        holoAng(1, entity():angles())
        
        #print(H)
    }
    
    function getInput() {
        Driver = Chair1:driver()
        Active = Driver:isValid()
        if (Active) {
            W = Driver:keyForward()
            A = Driver:keyLeft()
            S = Driver:keyBack()
            D = Driver:keyRight()
            R = Driver:keyReload()
            Shift = Driver:keySprint()
            Space = Driver:keyJump()
            Mouse1 = Driver:keyAttack1()
            
            #ifdef entity:setfLight(vector, vector, angle, string, number, number, number)
            LightKey = Driver:keyPressed("l")
            #endif
        }
    }
    
    #ifdef entity:setfLight(vector, vector, angle, string, number, number, number)
    function removeLights() {
        entity():fLightRemove()
    }
    
    function handleLights() {
        LightsOn = !LightsOn
        
        if (LightsOn) {
            entity():setfLight(entity():toWorld(LIGHTS_POS), vec(255), entity():toWorld(ang(LIGHTS_FOV / 2, -90, 0)), LIGHTS_MATERIAL, LIGHTS_FOV, LIGHTS_LENGTH, 10)
        }
        else {
            removeLights()
        }
    }
    #endif
    
    function computeDirections() {
        Speed = -entity():velL()[2]
        
        Up = entity():up()
        
        Right = entity():forward()
        Forward = entity():right()
        
        local RotateAngle = ang(0, Rotate, 0)
        RotateForward = entity():toWorld(RotateAngle):right()
        RotateRight = entity():toWorld(RotateAngle):forward()
    }
    
    function prepareWheelPoses() {
        for (I = 1, 4) {
            local WheelPos = entity():toWorld(WHEEL_LOCAL_POSES[I, vector])
            WheelPoses[I, vector] = WheelPos
            
            WheelVelocities[I, vector] = (WheelPos - WheelPosesOld[I, vector]) / tickInterval()
            WheelPosesOld[I, vector] = WheelPos
        }
        
        if (FirstTick) {
            FirstTick = 0
            exit()
        }
        
        WheelRealForwardVelocity[1] = WheelVelocities[1, vector]:dot(RotateForward)
        WheelRealForwardVelocity[2] = WheelVelocities[2, vector]:dot(RotateForward)
        WheelRealForwardVelocity[3] = WheelVelocities[3, vector]:dot(Forward)
        WheelRealForwardVelocity[4] = WheelVelocities[4, vector]:dot(Forward)
        
        WheelRealForwardVelocityOld = WheelRealForwardVelocity
    }
    
    function hangleSuspension() {
        for (I = 1, 4) {
            local Ranger = WheelRangers[I, ranger] = rangerOffset(SUSPENSION_HEIGHT, WheelPoses[I, vector], -Up)
            
            RangerHits[I] = Ranger:hit()
            RangerDistances[I] = Ranger:distance()
            
            Force[I, vector] = Up * (
                SUSPENSION_STRENGTH * (SUSPENSION_HEIGHT - RangerDistances[I])
                - SUSPENSION_STABILITY * WheelVelocities[I, vector]:dot(Up)
            )
        }
    }
    
    function handleRotate() {
        local RawButtonRotate = (A - D) * ROTATE_MAX * BUTTON_ROTATE_FADE / (abs(Speed) + BUTTON_ROTATE_FADE)
        ButtonRotate += (RawButtonRotate - ButtonRotate) * ROTATE_SMOOTH
        
        local MouseRotate = 0
        if (Mouse1) {
            MouseRotate = clamp(angnorm(Chair1:toLocal(Driver:eyeAngles())[2] - 90 - RotateCamOffset), -ROTATE_MAX, ROTATE_MAX)
        }
        if (changed(Mouse1)) {
            if (Mouse1) {
                RotateCamOffset = MouseRotate - Rotate
            }
        }
        RotateCamOffset += ROTATE_CAM_OFFSET_FADE_SPEED * clamp(-RotateCamOffset, -ROTATE_CAM_OFFSET_FADE, ROTATE_CAM_OFFSET_FADE) * tickInterval()
        
        local StabilizationRotate = 0
        if (MOVE_STABILIZATION & Speed > MOVE_SMALL_SPEED) {
            local RotatedVel = vec2(entity():velL()):rotate(MouseRotate + ButtonRotate)
            StabilizationRotate = MOVE_STABILIZATION_ROTATE_MULTIPLIER * (atan(RotatedVel[1] / abs(RotatedVel[2])) - (MouseRotate + ButtonRotate))
            
            # Nan check
            if (!(StabilizationRotate == StabilizationRotate)) {
                StabilizationRotate = 0
            }
        }
        
        Rotate = clamp(MouseRotate + ButtonRotate + StabilizationRotate, -ROTATE_MAX, ROTATE_MAX)
        
        #[if (Mouse1) {
            local TempRotate = angnorm(Chair1:toLocal(Driver:eyeAngles())[2] - 90 - RotateCamOffset)
            if (RotateCamOffset == 0) {
                RotateCamOffset = TempRotate - Rotate
            }
            
            if (MOVE_STABILIZATION & Speed > MOVE_SMALL_SPEED) {
                local RotatedVel = vec2(entity():velL()):rotate(TempRotate)
                TempRotate += MOVE_STABILIZATION_ROTATE_MULTIPLIER * (atan(RotatedVel[1] / abs(RotatedVel[2])) - TempRotate)
                
                if (!(TempRotate == TempRotate)) {
                    TempRotate = 0
                }
            }
            
            Rotate = clamp(TempRotate, -ROTATE_MAX, ROTATE_MAX)
        }
        else {
            local TempRotate = (A - D) * ROTATE_MAX * BUTTON_ROTATE_FADE / (abs(Speed) + BUTTON_ROTATE_FADE)
            
            if (MOVE_STABILIZATION) {
                if (Speed > MOVE_SMALL_SPEED) {
                    local RotatedVel = vec2(entity():velL()):rotate(TempRotate)
                    TempRotate += MOVE_STABILIZATION_ROTATE_MULTIPLIER * (atan(RotatedVel[1] / abs(RotatedVel[2])) - TempRotate)
                    
                    if (!(TempRotate == TempRotate)) {
                        TempRotate = 0
                    }
                }
            }
            Rotate += (TempRotate - Rotate) * ROTATE_SMOOTH
            
            RotateCamOffset = 0
        }]#
    }
    
    function prepareWantVelocity() {
        local Power = 0
        if (W) {
            Power += 1
            if (Shift) {
                Power += MOVE_SHIFT_MULTIPLIER
            }
        }
        if (S) {
            # Revers
            if (Speed < MOVE_SMALL_SPEED) {
                Power -= 0.5
            }
            # Stop
            else {
                if (MOVE_STABILIZATION) {
                    WheelWantForwardVelocity -= WHEELS_ALL * WheelIsStabilized * clamp(MOVE_STOP_POWER * WheelWantForwardVelocity, -MOVE_MAX_STOP_POWER, MOVE_MAX_STOP_POWER)
                }
                else {
                    WheelWantForwardVelocity -= WHEELS_ALL * clamp(MOVE_STOP_POWER * WheelWantForwardVelocity, -MOVE_MAX_STOP_POWER, MOVE_MAX_STOP_POWER)
                }
            }
        }
        # Hand brake
        elseif (Space | !Active) {
            if (MOVE_STABILIZATION) {
                WheelWantForwardVelocity -= WHEELS_REAR * WheelIsStabilized * clamp(MOVE_STOP_POWER * WheelWantForwardVelocity, -MOVE_MAX_STOP_POWER, MOVE_MAX_STOP_POWER)
            }
            else {
                WheelWantForwardVelocity -= WHEELS_REAR * clamp(MOVE_STOP_POWER * WheelWantForwardVelocity, -MOVE_MAX_STOP_POWER, MOVE_MAX_STOP_POWER)
            }
        }
        # Stabilization
        if (MOVE_STABILIZATION) {
            if (!WheelIsStabilized[1] & !WheelIsStabilized[2]) {
                WheelWantForwardVelocity -= WHEELS_ALL * WheelIsStabilized * clamp(MOVE_STOP_POWER * WheelWantForwardVelocity, -MOVE_MAX_STOP_POWER, MOVE_MAX_STOP_POWER)
                #[# Left
                if (Rotate < 0) {
                    WheelWantForwardVelocity -= WHEELS_RIGHT * WheelIsStabilized * clamp(MOVE_STOP_POWER * WheelWantForwardVelocity, -MOVE_MAX_STOP_POWER, MOVE_MAX_STOP_POWER)
                }
                # Right
                else {
                    WheelWantForwardVelocity -= WHEELS_LEFT * WheelIsStabilized * clamp(MOVE_STOP_POWER * WheelWantForwardVelocity, -MOVE_MAX_STOP_POWER, MOVE_MAX_STOP_POWER)
                }]#
            }
        }
        
        # Accelerate
        WheelWantForwardVelocity += (WheelRealForwardVelocity - WheelRealForwardVelocityOld) * RangerHits
        # Power from engine
        if (MOVE_STABILIZATION) {
            WheelWantForwardVelocity += MOVE_MAX_POWER * Power * MOVE_POWER_WHEELS * WheelIsStabilized
        }
        else {
            WheelWantForwardVelocity += MOVE_MAX_POWER * Power * MOVE_POWER_WHEELS
        }
    }
        
    function computeTorqueForce() {
        local WheelFriction = WHELL_MAX_FRICTION * mix(VEC4_1, WheelNotSkid, MOVE_SKID_MULTIPLIER)
        
        local WheelDeltaForwardVelocity = (WheelWantForwardVelocity - WheelRealForwardVelocity) * RangerHits
        
        for (I = 1, 2) {
            # Multiply max friction on pressure
            WheelFriction[I] = WheelFriction[I] * Force[I, vector]:length()
            
            # Compute skid
            local TempForce = 
                # Torque
                WHEEL_STREHTH * WheelDeltaForwardVelocity[I] * RotateForward
                # Side friction
                + WHEEL_STREHTH * -WheelVelocities[I, vector]:dot(RotateRight) * RotateRight
            
            # Check wheel is friction
            WheelNotSkid[I] = TempForce:length() <= WheelFriction[I]
            if (MOVE_STABILIZATION) {
                WheelIsStabilized[I] = TempForce:length() <= WheelFriction[I] * MOVE_STABILIZATION_MOVE_PERCENT
            }
            
            Force[I, vector] = FORCE_MULTIPLIER * (Force[I, vector] + clamp(TempForce, 0, WheelFriction[I])) * RangerHits[I]
        }
        
        # Repeat for not rotate forward and right vectors
        for (I = 3, 4) {
            WheelFriction[I] = WheelFriction[I] * Force[I, vector]:length()
            
            local TempForce = 
                WHEEL_STREHTH * WheelDeltaForwardVelocity[I] * Forward
                + WHEEL_STREHTH * -WheelVelocities[I, vector]:dot(Right) * Right
            
            WheelNotSkid[I] = TempForce:length() <= WheelFriction[I]
            if (MOVE_STABILIZATION) {
                WheelIsStabilized[I] = TempForce:length() <= WheelFriction[I] * MOVE_STABILIZATION_MOVE_PERCENT
            }
            
            Force[I, vector] = FORCE_MULTIPLIER * (Force[I, vector] + clamp(TempForce, 0, WheelFriction[I])) * RangerHits[I]
        }
        
        # Wheel back friction
        WheelWantForwardVelocity -= clamp(WHEEL_SPEED_FADE * WheelDeltaForwardVelocity, -1 * WheelFriction, WheelFriction)
    }
    
    function moveCar() {
        local ForceCenter = (Force[1, vector] + Force[2, vector] + Force[3, vector] + Force[4, vector]) / 4
        for (I = 1, 4) {
            entity():applyOffsetForce((Force[I, vector] - ForceCenter), WheelPoses[I, vector])
        }
        
        entity():applyForce(ForceCenter * 4)
        entity():applyAngForce(-MOVE_REALISTIC_MULTIPLIER * ang(ForceCenter:dot(Right), 0, ForceCenter:dot(Forward)))
        
        # Rotating if auto upside down
        if (R) {
            entity():applyAngForce(-entity():angles() * ang(1, 0, 1) * 300 * FORCE_MULTIPLIER)
        }
    }
    
    #[function moveCar() {
        # Replace for applyOffsetForce
        local ForceCenter = (Force[1, vector] + Force[2, vector] + Force[3, vector] + Force[4, vector]) / 4
        
        local ForceAng2 = 0
        for (I = 1, 4) {
            ## Sub individual velocity
            Force[I, vector] = Force[I, vector] - ForceCenter
            
            ## Rotate
            ForceAng2 += Force[I, vector]:dot(Up:cross(WheelPoses[I, vector] - entity():pos()))
        }
        
        ## Suspension
        ### Left-Right
        local ForceAng1 = ((Force[2, vector] + Force[4, vector]) - (Force[1, vector] + Force[3, vector])):dot(Up) * WHEEL_LOCAL_POSES[1, vector][1]
        ### Forward-Backward
        local ForceAng3 = ((Force[1, vector] + Force[2, vector]) - (Force[3, vector] + Force[4, vector])):dot(Up) * WHEEL_LOCAL_POSES[1, vector][2]
        entity():applyAngForce(ang(ForceAng1, ForceAng2, ForceAng3))
        
        entity():applyForce(ForceCenter * 4)
        entity():applyAngForce(-MOVE_REALISTIC_MULTIPLIER * ang(ForceCenter:dot(Right), 0, ForceCenter:dot(Forward)))
        
        # Rotating if auto upside down
        if (R) {
            entity():applyAngForce(-entity():angles() * ang(1, 0, 1) * FORCE_MULTIPLIER * 300)
        }
    }]#
    
    function moveHolo() {
        #Rulb
        holoAng(HOLO_OFFSET_STEERING_WHEEL, entity():toWorld(ang(-10, 90, ROTATE_RUL_MULTIPLIER * Rotate)))
        
        #Wheels
        WheelAngles -= toDeg(WheelWantForwardVelocity / WHEEL_SIZES) * tickInterval()
        for (I = 1, 4) {
            holoPos(HOLO_OFFSET_WHEELS + I, entity():toWorld(WHEEL_LOCAL_POSES[I, vector] + Up * min(WHEEL_SIZES[I] / 2 - RangerDistances[I], HOLO_WHEEL_MAX_HEIGHT[I])))
        }
        
        holoAng(HOLO_OFFSET_WHEELS + 1, entity():toWorld(ang( WheelAngles[1], Rotate + 90, 90)))
        holoAng(HOLO_OFFSET_WHEELS + 2, entity():toWorld(ang(-WheelAngles[2], Rotate - 90, 90)))
        holoAng(HOLO_OFFSET_WHEELS + 3, entity():toWorld(ang( WheelAngles[3], 90, 90)))
        holoAng(HOLO_OFFSET_WHEELS + 4, entity():toWorld(ang(-WheelAngles[4], -90, 90)))
        
        # Smoke
        #[for (I = 1, 4) {
            holoColor(HOLO_OFFSET_WHEELS + I, vec(20) + vec(100 * (1 - WheelNotSkid[I]) * RangerHits[I], 0, 0))
        }]#
    }
}

if (first()) {
    configure()
    initialize()
    drawBody()
}

if (tickClk()) {
    getInput()
    computeDirections()
    handleRotate()
    
    prepareWheelPoses()
    hangleSuspension()
    handleRotate()
    prepareWantVelocity()
    computeTorqueForce()
    moveCar()
    moveHolo()
}

#ifdef entity:setfLight(vector, vector, angle, string, number, number, number)
if (changed(LightKey) & LightKey & !first()) {
    handleLights()
}

if (last()) {
    removeLights()
}
#endif
